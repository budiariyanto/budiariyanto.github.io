<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: MySQL | My Personal Blog]]></title>
  <link href="http://budiariyanto.github.io/blog/categories/mysql/atom.xml" rel="self"/>
  <link href="http://budiariyanto.github.io/"/>
  <updated>2014-06-16T18:27:22+07:00</updated>
  <id>http://budiariyanto.github.io/</id>
  <author>
    <name><![CDATA[Budi Ariyanto]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[SQL Exclusion Join]]></title>
    <link href="http://budiariyanto.github.io/blog/2010/11/01/sql-exclusion-join/"/>
    <updated>2010-11-01T14:01:00+07:00</updated>
    <id>http://budiariyanto.github.io/blog/2010/11/01/sql-exclusion-join</id>
    <content type="html"><![CDATA[<div class='post'>
We know that SQL has a join syntax to query data within two tables. For example I have two tables and data like this&nbsp;:<br /><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><b>Rose</b></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">type &nbsp; &nbsp;| &nbsp; &nbsp;price</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">-----------------------</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">Red &nbsp; &nbsp; | &nbsp; &nbsp; &nbsp;2</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">White &nbsp; | &nbsp; &nbsp; &nbsp;6</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><br /></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><b>Lily</b></span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">type &nbsp; &nbsp; &nbsp; &nbsp; &nbsp; | &nbsp; &nbsp;price</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">------------------------------</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">Bowl Shaped &nbsp; &nbsp;| &nbsp; &nbsp; &nbsp;5</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">Trumpet Shaped | &nbsp; &nbsp; &nbsp;6</span><br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><br /></span><br />If we use a join, the tables must have condition to join them. But, how if we want to query data from one tables which doesn't exist in the other table? For example, I want to retrieve price of rose that not match in the lily? The answer is :<br /><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;">select * from rose a where a.price </span><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"><b>not in</b></span><span class="Apple-style-span" style="font-family: 'Courier New', Courier, monospace;"> (select b.price from lily b)&nbsp;</span><br /><br />I hope this can help you for querying data. :D</div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[What's New in MySQL 5.1]]></title>
    <link href="http://budiariyanto.github.io/blog/2008/12/10/what-new-in-mysql-51/"/>
    <updated>2008-12-10T15:17:00+07:00</updated>
    <id>http://budiariyanto.github.io/blog/2008/12/10/what-new-in-mysql-51</id>
    <content type="html"><![CDATA[<div class='post'>
The following features have been added to MySQL 5.1.<br/><div class="itemizedlist"><br/><ul><br/>   <li><strong>Partitioning. </strong> This capability enables distributing portions of               individual tables across a filesystem, according to rules               which can be set when the table is created. In effect,               different portions of a table are stored as separate               tables in different locations, but from the user point of               view, the partitioned table is still a single table.               Syntactically, this implements a number of new extensions               to the <a title="12.1.17. CREATE TABLE Syntax" href="http://dev.mysql.com/doc/refman/5.1/en/create-table.html"><code class="literal">CREATE TABLE</code></a>,               <a title="12.1.7. ALTER TABLE Syntax" href="http://dev.mysql.com/doc/refman/5.1/en/alter-table.html"><code class="literal">ALTER TABLE</code></a>, and               <code class="literal">EXPLAIN ... SELECT</code> statements. As of               MySQL 5.1.6, queries against partitioned tables can take               advantage of <span class="emphasis"><em>partition pruning</em></span>. In               some cases, this can result in query execution that is an               order of magnitude faster than the same query against a               non-partitioned version of the same table. See               <a title="Chapter 18. Partitioning" href="http://dev.mysql.com/doc/refman/5.1/en/partitioning.html">Chapter 18, <em>Partitioning</em></a>, for further information on               this functionality. (Author: Mikael Ronström)</li><br/>  <li><strong>Row-based replication. </strong> Replication capabilities in MySQL originally were based on               propagation of SQL statements from master to slave. This               is called <span class="emphasis"><em>statement-based               replication</em></span>. As of MySQL 5.1.5, another basis               for replication is available. This is called               <span class="emphasis"><em>row-based replication</em></span>. Instead of               sending SQL statements to the slave, the master writes               events to its binary log that indicate how individual               table rows are effected. As of MySQL 5.1.8, a third option               is available: <span class="emphasis"><em>mixed</em></span>. This will use               statement-based replication by default, and only switch to               row-based replication in particular cases. See               <a title="16.1.2. Replication Formats" href="http://dev.mysql.com/doc/refman/5.1/en/replication-formats.html">Section 16.1.2, “Replication Formats”</a>. (Authors: Lars               Thalmann, Guilhem Bichot, Mats Kindahl)</li><br/> <li><strong>Plugin API. </strong> MySQL 5.1 adds support for a very flexible plugin API that               enables loading and unloading of various components at               runtime, without restarting the server. Although the work               on this is not finished yet, <span class="emphasis"><em>plugin full-text               parsers</em></span> are a first step in this direction.               This allows users to implement their own input filter on               the indexed text, enabling full-text search capability on               arbitrary data such as PDF files or other document               formats. A pre-parser full-text plugin performs the actual               parsing and extraction of the text and hands it over to               the built-in MySQL full-text search. See               <a title="22.2. The MySQL Plugin Interface" href="http://dev.mysql.com/doc/refman/5.1/en/plugin-api.html">Section 22.2, “The MySQL Plugin Interface”</a>. (Author: Sergey Vojtovich)</li><br/> <li><strong>Event scheduler. </strong> MySQL Events are tasks that run according to a schedule.               When you create an event, you are creating a named               database object containing one or more SQL statements to               be executed at one or more regular intervals, beginning               and ending at a specific date and time. Conceptually, this               is similar to the idea of the Unix               <code class="literal">crontab</code> (also known as a “<span class="quote">cron               job</span>”) or the Windows Task Scheduler. See               <a title="19.4. Using the Event Scheduler" href="http://dev.mysql.com/doc/refman/5.1/en/events.html">Section 19.4, “Using the Event Scheduler”</a>. (Author: Andrey Hristov)</li><br/>  <li><strong>Server log tables. </strong> Before MySQL 5.1, the server writes general query log and               slow query log entries to log files. As of MySQL 5.1, the               server's logging capabilities for these logs are more               flexible. Log entries can be written to log files (as               before) or to the               <a href="http://dev.mysql.com/doc/refman/5.1/en/server-system-variables.html#sysvar_general_log"><code class="literal">general_log</code></a> and               <code class="literal">slow_log</code> tables in the               <code class="literal">mysql</code> database. If logging is enabled,               either or both destinations can be selected. The               <code class="option">--log-output</code> option controls the               destination or destinations of log output. See               <a title="5.2.1. Selecting General Query and Slow Query Log Output Destinations" href="http://dev.mysql.com/doc/refman/5.1/en/log-tables.html">Section 5.2.1, “Selecting General Query and Slow Query Log Output Destinations”</a>. (Author: Petr Chardin)</li><br/>  <li><strong>Upgrade program. </strong> The <a title="4.4.8. mysql_upgrade — Check Tables for MySQL Upgrade" href="http://dev.mysql.com/doc/refman/5.1/en/mysql-upgrade.html"><span><strong class="command">mysql_upgrade</strong></span></a> program (available as               of MySQL 5.1.7) checks all existing tables for               incompatibilities with the current version of MySQL Server               and repairs them if necessary. This program should be run               for each MySQL upgrade. See               <a title="4.4.8. mysql_upgrade — Check Tables for MySQL Upgrade" href="http://dev.mysql.com/doc/refman/5.1/en/mysql-upgrade.html">Section 4.4.8, “<span><strong class="command">mysql_upgrade</strong></span> — Check Tables for MySQL Upgrade”</a>. (Authors: Alexey               Botchkov, Mikael Widenius)</li><br/>  <li><strong>MySQL Cluster. </strong> MySQL Cluster is now released as a separate product, based               on MySQL 5.1 but with the addition of the               <code class="literal">NDBCLUSTER</code> storage engine. Clustering               support is no longer available in mainline MySQL 5.1               releases. MySQL Cluster releases are identified by a               3-part NDB version number; currently, the MySQL Cluster               NDB 6.2 and MySQL Cluster NDB 6.3 release series are               available for production use.<br/><br/>Some of the changes in MySQL Cluster since MySQL 5.0 are             listed here:<br/><div class="itemizedlist"><br/><ul><br/> <li><strong>MySQL Cluster replication. </strong> Replication between MySQL Clusters is now supported.                     It is now also possible to replicate between a MySQL                     Cluster and a non-cluster database. See                     <a title="17.11. MySQL Cluster Replication" href="http://dev.mysql.com/doc/refman/5.1/en/mysql-cluster-replication.html">Section 17.11, “MySQL Cluster Replication”</a>.</li><br/> <li><strong>MySQL Cluster disk data storage. </strong> Formerly, the <code class="literal">NDBCLUSTER</code> storage                     engine was strictly in-memory; now, it is possible                     to store Cluster data (but not indexes) on disk.                     This allows MySQL Cluster to scale upward with fewer                     hardware (RAM) requirements than previously. In                     addition, the Disk Data implementation includes a                     new “<span class="quote">no-steal</span>” restoration algorithm                     for fast node restarts when storing very large                     amounts of data (terabyte range). See                     <a title="17.12. MySQL Cluster Disk Data Tables" href="http://dev.mysql.com/doc/refman/5.1/en/mysql-cluster-disk-data.html">Section 17.12, “MySQL Cluster Disk Data Tables”</a>, for more                     information.</li><br/> <li><strong>Improved backups for MySQL Cluster. </strong> A fault arising in a single data node during a                     Cluster backup no longer causes the entire backup to                     be aborted, as occurred in previous versions of                     MySQL Cluster.</li><br/></ul><br/></div><br/>Many other new features and improvements have been made to             the <code class="literal">NDBCLUSTER</code> storage engine in MySQL             Cluster NDB 6.2 and MySQL Cluster NDB 6.3; for more             information about these, see             <a title="17.15. MySQL Cluster Development Roadmap" href="http://dev.mysql.com/doc/refman/5.1/en/mysql-cluster-roadmap.html">Section 17.15, “MySQL Cluster Development Roadmap”</a>.</li><br/> <li><strong>Backup of tablespaces. </strong> The <a title="4.5.4. mysqldump — A Database Backup Program" href="http://dev.mysql.com/doc/refman/5.1/en/mysqldump.html"><span><strong class="command">mysqldump</strong></span></a> utility now supports an               option for dumping tablespaces. Use <code class="option">-Y</code> or               <code class="option">--all-tablespaces</code> to enable this               functionality.</li><br/>  <li><strong>Improvements to <code class="literal">INFORMATION_SCHEMA</code>. </strong> MySQL 5.1 provides much more information in its metadata               database than was available in MySQL 5.0. New tables in               the <code class="literal">INFORMATION_SCHEMA</code> database include               <a title="20.21. The INFORMATION_SCHEMA FILES Table" href="http://dev.mysql.com/doc/refman/5.1/en/files-table.html"><code class="literal">FILES</code></a>,               <a title="20.20. The INFORMATION_SCHEMA EVENTS Table" href="http://dev.mysql.com/doc/refman/5.1/en/events-table.html"><code class="literal">EVENTS</code></a>,               <a title="20.19. The INFORMATION_SCHEMA PARTITIONS Table" href="http://dev.mysql.com/doc/refman/5.1/en/partitions-table.html"><code class="literal">PARTITIONS</code></a>,               <a title="20.22. The INFORMATION_SCHEMA PROCESSLIST Table" href="http://dev.mysql.com/doc/refman/5.1/en/processlist-table.html"><code class="literal">PROCESSLIST</code></a>,               <a title="20.18. The INFORMATION_SCHEMA ENGINES Table" href="http://dev.mysql.com/doc/refman/5.1/en/engines-table.html"><code class="literal">ENGINES</code></a>, and               <a title="20.17. The INFORMATION_SCHEMA PLUGINS Table" href="http://dev.mysql.com/doc/refman/5.1/en/plugins-table.html"><code class="literal">PLUGINS</code></a>.</li><br/>    <li><strong>XML functions with XPath support. </strong> <a href="http://dev.mysql.com/doc/refman/5.1/en/xml-functions.html#function_extractvalue"><code class="literal">ExtractValue()</code></a> returns the               content of a fragment of XML matching a given XPath               expression. <a href="http://dev.mysql.com/doc/refman/5.1/en/xml-functions.html#function_updatexml"><code class="literal">UpdateXML()</code></a> replaces the element selected from a fragment of XML by an               XPath expression supplied by the user with a second XML               fragment (also user-supplied), and returns the modified               XML. See <a title="11.10. XML Functions" href="http://dev.mysql.com/doc/refman/5.1/en/xml-functions.html">Section 11.10, “XML Functions”</a>. (Author:               Alexander Barkov)</li><br/>   <li><strong>Load emulator. </strong> The <a title="4.5.7. mysqlslap — Load Emulation Client" href="http://dev.mysql.com/doc/refman/5.1/en/mysqlslap.html"><span><strong class="command">mysqlslap</strong></span></a> program is designed to               emulate client load for a MySQL server and report the               timing of each stage. It works as if multiple clients were               accessing the server. See <a title="4.5.7. mysqlslap — Load Emulation Client" href="http://dev.mysql.com/doc/refman/5.1/en/mysqlslap.html">Section 4.5.7, “<span><strong class="command">mysqlslap</strong></span> — Load Emulation Client”</a>.               (Authors: Patrick Galbraith, Brian Aker)</li><br/></ul><br/>Sumber : <a title="MySQL" href="http://dev.mysql.com/doc/refman/5.1/en/mysql-nutshell.html" target="_blank">http://dev.mysql.com/doc/refman/5.1/en/mysql-nutshell.html</a></div></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Integritas Data Pada MySQL]]></title>
    <link href="http://budiariyanto.github.io/blog/2008/11/06/integritas-data-pada-mysql/"/>
    <updated>2008-11-06T23:10:00+07:00</updated>
    <id>http://budiariyanto.github.io/blog/2008/11/06/integritas-data-pada-mysql</id>
    <content type="html"><![CDATA[<div class='post'>
Beberapa teman saya kebingungan saat mereka berlatih programming yang melibatkan MySQL sebagai databasenya. Mereka bertanya-tanya : "MySQL kok nggak bisa ndetect referensial integrity y??Padahal primary key dan foreign key nya udah di set..". Begitu kira-kira seputar kebingungan mereka... Nah bagi Anda yang mengalami masalah yang sama dengan teman-teman saya, Anda bisa mengikuti panduan yang saya buat di bawah ini :<br/><ol><br/>   <li>Cek dulu apakah MySQL sudah terkonfigurasi untuk support InnoDB storage engine. Biasanya secara default sudah enabled. Tapi jika belum, maka yang harus Anda lakukan adalah mencari file my.ini jika Anda menggunakan Windows, atau my.cnf jika Anda menggunakan linux. my.ini / my.cnf biasanya terletak di sekitar folder tempat MySQL terinstall. Pada kasus ini saya tidak bisa memastikan letaknya di mana karena kemungkinan Anda akan menggunakan webserver yang berbeda-beda, misal Apache2Triad, XAMPP atau WAMP.</li><br/>    <li>Jika sudah ketemu, buka file tersebut, dan cari baris dengan statement : <code>skip-innodb</code>. Jika MySQL Anda sudah dikonfigurasi untuk support InnoDB, maka Anda bisa melihat tanda "#" di depan <code>skip-innodb</code>. Maka dari itu, untuk mengkonfigurasi MySQL supaya support InnoDB, berilah tanda "#" di depan <code>skip-innodb</code>. Jika sudah, save my.ini / my.cnf lalu restart MySQL.</li><br/>  <li>Untuk memastikan apakah InnoDB sudah bekerja, masukkanlah kode berikut ke dalam MySQL: [sourcecode language="sql"]CREATE TABLE customer (customer_id INT, name VARCHAR(30), PRIMARY KEY (customer_id)) ENGINE = INNODB ;[/sourcecode]<br/><br/>Kode di atas untuk membuat table parent. Sekarang buatlah table child dengan mengetikkan kode di bawah ini :<br/><br/>[sourcecode language="sql"]<br/>CREATE TABLE customer_sales ( transaction_id INT,amount INT,customer_id INT NOT NULL, PRIMARY KEY(transaction_id), INDEX(customer_id), FOREIGN KEY(customer_id) REFERENCES customer(customer_id)) ENGINE = INNODB;<br/>[/sourcecode]</li><br/> <li> Jika sudah cobalah insert data langsung pada tabel anak. Seharusnya akan gagal karena pada tabel parent belum terisi apa-apa. [sourcecode language="sql"]INSERT INTO customer_sales VALUES(1,23,1),(3,81,2);[/sourcecode]</li><br/>    <li>Jika Anda mengalami kegagalan dalam memasukkan data karena menjalankan perintah yang ada pada nomor 4, berarti InnoDB telah benar-benar bekerja pada MySQL. Dan jangan khawatir, integritas data juga akan terjaga pada proses update dan delete. :D</li><br/></ol></div>

]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[BACKUP(DUMPING) DAN RESTORE DATABASE MySQL]]></title>
    <link href="http://budiariyanto.github.io/blog/2008/06/11/backupdumping-dan-restore-database/"/>
    <updated>2008-06-11T23:56:00+07:00</updated>
    <id>http://budiariyanto.github.io/blog/2008/06/11/backupdumping-dan-restore-database</id>
    <content type="html"><![CDATA[<div class='post'>
Setiap database penting untuk di-backup agar tidak terjadi bencana ketika sewaktu-waktu database yang Anda punya rusak, karena mati listrik mungkin... Atau mungkin suatu saat Anda ingin memindahkan database Anda ke komputer lain.. Who knows...? Ini saya ada tutorial untuk dumping dan restore database MySQL.<br /><br /><b>DUMPING:</b><br /><br />Pertama, Anda harus tahu dulu username dan password yang dapat mengakses database yang akan di-backup(sebaiknya user yang mempunyai hak akses penuh terhadap database). Misalnya usernamenya budi, passwordnya budiganteng dan nama databasenya db_budi. Setelah itu ketikkan pada command prompt :<br /><br />[sourcecode language='sql']mysqldump -u budi -p budiganteng db_budi &gt; C:\backup\db_budi_backup.sql[/sourcecode]<br /><br />Hasil file backup berupa file berekstensi .sql, dan dalam kasus ini nantinya file yang tercipta adalah db_budi_backup.sql yang terletak di C:\backup.<br /><br /><b>RESTORE:</b><br /><br />Pertama, Anda buat dulu database di komputer lainnya(sebut saja komputer B) dengan nama database yang sama dengan database di komputer sebelumnya, dalam kasus ini, nama databasenya adalah db_budi dengan mengetikkan perintah create database db_budi. Di samping itu, di komputer B harus ada username budi dengan password budiganteng dengan level hak akses yang sama terhadap database di komputer sebelumnya, dalam kasus ini anggap saja admin. Jika belum ada, ketikkan perintah ini :<br /><br />[sourcecode language='sql']grant all on db_budi.* to 'budi'@'localhost' identified by 'budiganteng'[/sourcecode]<br /><br />Setelah user dibuat, pada command prompt  ketikkan perintah :<br /><br />[sourcecode language='sql']mysql -u budi -p budiganteng db_budi &lt; C:\backup\db_budi_backup.sql[/sourcecode]<br /><br />Setelah perintah ini dijalankan, maka Anda sudah me-restore database MySQL yang diinginkan.</div>

]]></content>
  </entry>
  
</feed>
